/*
_  ______   _____ _____ _____ _   _
| |/ / ___| |_   _| ____/___ | | | |
| ' / |  _    | | |  _|| |   | |_| |
| . \ |_| |   | | | |__| |___|  _  |
|_|\_\____|   |_| |_____\____|_| |_|

ANYWAY, YOU MUST GIVE CREDIT TO MY CODE WHEN COPY IT
CONTACT ME HERE +237656520674
YT: KermHackTools
Github: Kgtech-cmr
*/

const config = require('../config');
const { Sticker, StickerTypes } = require('wa-sticker-formatter');
const { cmd } = require('../command');
const { getRandom } = require('../lib/functions');
/*
cmd(
    {
        pattern: 'take',
        alias: ['steal', 'stake'],
        desc: 'Create a sticker with a custom pack name.',
        category: 'sticker',
        use: '<reply media or URL>',
        filename: __filename,
    },
    async (conn, mek, m, { quoted, args, q, reply, from }) => {
        if (!mek.quoted) return reply(`*Reply to any sticker.*`);
        if (!q) return reply(`*Please provide a pack name using .take <packname>*`);

        let mime = mek.quoted.mtype;
        let pack = q;

        if (mime === "stickerMessage") { // Change to handle only sticker messages
            let media = await mek.quoted.download();
            let sticker = new Sticker(media, {
                pack: pack, 
                type: StickerTypes.FULL,
                categories: ["ü§©", "üéâ"],
                id: "12345",
                quality: 75,
                background: 'transparent',
            });
            const buffer = await sticker.toBuffer();
            return conn.sendMessage(mek.chat, { sticker: buffer }, { quoted: mek });
        } else {
            return reply("*Uhh, Please reply to a sticker.*"); // Update the message to indicate sticker
        }
    }
);
*/
//Sticker create 
var imgmsg = '';
if (config.LANG === 'SI') imgmsg = '‡∂°‡∑è‡∂∫‡∑è‡∂ª‡∑ñ‡∂¥‡∂∫‡∂ö‡∂ß mention ‡∂Ø‡∑ô‡∂±‡∑ä‡∂±!';
else imgmsg = ' Ä·¥á·¥ò ü è ·¥õ·¥è ·¥Ä ·¥ò ú·¥è·¥õ·¥è “ì·¥è Ä s·¥õ…™·¥Ñ·¥ã·¥á Ä!';

var descg = '';
if (config.LANG === 'SI') descg = '‡∂ë‡∂∫ ‡∂î‡∂∂‡∂ú‡∑ö mention ‡∂Ø‡∑î‡∂±‡∑ä ‡∂°‡∑è‡∂∫‡∑è‡∂ª‡∑ñ‡∂¥‡∂∫ ‡∑É‡∑ä‡∂ß‡∑í‡∂ö‡∂ª‡∑ä ‡∂∂‡∑Ä‡∂ß ‡∂¥‡∂ª‡∑í‡∑Ä‡∂ª‡∑ä‡∂≠‡∂±‡∂∫ ‡∂ö‡∂ª‡∂∫‡∑í.';
else descg = '…™·¥õ ·¥Ñ·¥è…¥·¥†·¥á Ä·¥õs  è·¥è·¥ú Ä  Ä·¥á·¥ò ü…™·¥á·¥Ö ·¥ò ú·¥è·¥õ·¥è ·¥õ·¥è s·¥õ…™·¥Ñ·¥ã·¥á Ä.';

cmd({
    pattern: 'sticker',
    react: 'ü§π‚Äç‚ôÄÔ∏è',
    alias: ['s', 'stickers'],
    desc: descg,
    category: 'convert',
    use: '.sticker <Reply to image>',
    filename: __filename
}, async (conn, mek, m, { from, reply, isCmd, command, args, q, isGroup, pushname }) => {
    try {
        const isQuotedImage = m.quoted && (m.quoted.type === 'imageMessage' || (m.quoted.type === 'viewOnceMessage' && m.quoted.msg.type === 'imageMessage'));
        const isQuotedSticker = m.quoted && m.quoted.type === 'stickerMessage';

        if ((m.type === 'imageMessage') || isQuotedImage) {
            const nameJpg = getRandom('.jpg');
            const imageBuffer = isQuotedImage ? await m.quoted.download() : await m.download();
            await require('fs').promises.writeFile(nameJpg, imageBuffer);

            let sticker = new Sticker(nameJpg, {
                pack: pushname, // The pack name
                author: '', // The author name
                type: q.includes('--crop') || q.includes('-c') ? StickerTypes.CROPPED : StickerTypes.FULL,
                categories: ['ü§©', 'üéâ'], // The sticker category
                id: '12345', // The sticker id
                quality: 75, // The quality of the output file
                background: 'transparent', // The sticker background color (only for full stickers)
            });

            const buffer = await sticker.toBuffer();
            return conn.sendMessage(from, { sticker: buffer }, { quoted: mek });
        } else if (isQuotedSticker) {
            const nameWebp = getRandom('.webp');
            const stickerBuffer = await m.quoted.download();
            await require('fs').promises.writeFile(nameWebp, stickerBuffer);

            let sticker = new Sticker(nameWebp, {
                pack: pushname, // The pack name
                author: '', // The author name
                type: q.includes('--crop') || q.includes('-c') ? StickerTypes.CROPPED : StickerTypes.FULL,
                categories: ['ü§©', 'üéâ'], // The sticker category
                id: '12345', // The sticker id
                quality: 75, // The quality of the output file
                background: 'transparent', // The sticker background color (only for full stickers)
            });

            const buffer = await sticker.toBuffer();
            return conn.sendMessage(from, { sticker: buffer }, { quoted: mek });
        } else {
            return await reply(imgmsg);
        }
    } catch (e) {
        reply('Error !!');
        console.error(e);
    }
});

cmd({
    pattern: "take",
    desc: "Steal a sticker and resend it with a custom packname.",
    category: "sticker",
    react: "üé≠",
    filename: __filename,
    use: ".take [packname]"
}, async (conn, mek, m, { from, args, reply, sender }) => {
    try {
        // Check if the message is a reply containing a sticker
        const quotedSticker = m.quoted && m.quoted.message && m.quoted.message.stickerMessage;
        if (!quotedSticker) {
            return reply("‚ö†Ô∏è Please reply to a sticker using `.take` to modify it.");
        }

        // Download the sticker from the quoted message
        const media = await conn.downloadAndSaveMediaMessage(m.quoted);
        if (!media) return reply("‚ùå Failed to download the sticker.");

        // Define the packname: use provided argument or default to "@username"
        const packname = args.length > 0 ? args.join(" ") : `@${sender.split("@")[0]}`;
        const author = "KERM MD"; // Default author name

        // Create a temporary file name for the sticker
        const fileName = `./temp_${Date.now()}.webp`;
        writeFileSync(fileName, media);

        // Generate a new sticker with the custom packname using the stickerMetadata function
        const stickerBuffer = await stickerMetadata(fileName, { packname, author });

        // Send the modified sticker back to the chat, quoting the original message
        await conn.sendMessage(from, { sticker: stickerBuffer }, { quoted: mek });

        // Delete the temporary file
        unlinkSync(fileName);
    } catch (error) {
        console.error("Error in .take command:", error);
        reply("‚ùå An error occurred while modifying the sticker.");
    }
});